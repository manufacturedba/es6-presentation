section
    div Methods for Constructing Promises
section
    strong Q.fcall
    section
        div. 
            Q.fcall is the simplest way to turn any function into a "then-able".
    aside(class="notes").
        A thenable promise is a promise with a method of "then" which is used to retrieve the fulfillment or rejection value of a resolved promise.
    section(data-transition="slide-in fade-out")
        pre
            code.
                function addNumbers(a, b) {
                    return a + b;
                }
                
                console.log(addNumbers(2, 2));
                console.log('Blocked');
                
                4
                Blocked
        aside(class="notes").
            The benefit of the Node platform model is everything that should be asynchronous is asynchronous with exception to methods with Sync in its name such as readFileSync instead of the asynchronous version readFile.  However when we're creating new modules resembling Node's API we don't get the "error-first" asynchronous callback style for free.  We have to build it using .nextTick() to indicate it should be passed along to the event loop.

            So when building simple functions like this we're immediately blocking.  We can pretend that a function more or less represents a CPU intensive operation where we'd prefer to delay its execution until later.

            What does a simple function look like?
    section(data-transition="fade-in slide-out")
        pre
            code.
                function addNumbers(a, b) {
                    return Q.fcall(function(){
                        return a + b;
                    });
                }
                
                addNumbers(2, 2).then(console.log);
                console.log('Not blocked');
                
                Not blocked
                4
        aside(class="notes").
            Here's the example modified with Q.  When using the Q library we can use the helper function Q.fcall to easily construct a fulfilled promise out of any returned value.  If any exceptions are thrown, Q.fcall will capture them and hand us back a rejected promise, but we'll have no control over the rejection error itself.
section
    strong Q.Promise or Deferred
    section
        div.
            Q.Promise allows us to resolve, reject, or report progress
        aside(class="notes").
            Q.Promise is the purest form of Promises.  It exactly resembles what Promises will look like in ES6, but they're not always appropriate for the job.  The truth is we don't exactly have access to this with our current version of Q, but I'll show how we can still achieve it.
    section(data-transition="slide-in fade-out")
        pre
            code.
                function process(items) {
                    
                    return Q.Promise(function (resolve, reject, notify) {
                        
                        for (var i = 0, j = items; i < j.length; i++) {
                            if (j[i].type === 'error') {
                                reject('Encountered error');
                            } else {
                                j[i].processed = true;
                                notify((i + 1)/j.length);
                            }
                        }
                        
                        resolve(statuses);
                    });
                }
        aside(class="notes").
            So in this example Q.Promise takes a callback function as usual, but we have the ability to resolve, reject, and/or notify the user when something has updated.  This is extremely useful for file uploads.
    section(data-transition="fade-in slide-out")
        pre
            code.
                process(tickets)
                    .then(function (result) {
                        log.info('Done processing tickets');
                    })
                    .fail(function (err) {
                        log.error(err);
                    })
                    .progress(function (progress) {
                        log.debug(Math.round(progress * 100) + "%");
                    });
        aside(class="notes").
            Handling this promise remains the same as any other.  We have a .then, a .fail to capture any propogating errors or rejections, but we now .progress.  This is not part of the Promise specification by any means, but it's extra sugar on top of the standard promise.
    section
        div.
            Deferred constructed promises are much more suited to handling 
            non-promise returning asynchronous functions
        aside(class="notes").
            An example being Node-style callback functions.  We use this extensively in Angular as $q.defer();
    section
        pre
            code.
                function handleRequest (path) {
                    
                    var deferred = Q.defer();
                    
                    http.get(path, function (response) {
                        
                        response.on('data', deferred.resolve);
                        
                        response.on('error', deferred.reject);
                        
                    });
                    
                    return deferred.promise;
                }
        aside(class="notes").
            In this example, we're blending promises with event listeners as you might have to do when using the HTTP Node module.
section
    strong Q.all and spread
    section 
        div. 
            In some instances, we would like to fulfill multiple promises at once.
        aside(class="notes").    
            Because of the flexibility of Promises we can give Q.all an array of values (and/or promises) that when all of them are fulfilled
            will give pass an array of the fulfillment values of the passed promises.
            Q.all also has no problem maintaining the order in which promises are passed to it.  We're safe to use it in combination with functions that accept multiple 
    section
        pre
            code.
                var requests = [];
                requests.push(handleRequest('/tickets'));
                requests.push(handleRequest('/orders'));
                requests.push(handleRequest('/receipts'));
                
                Q.all(requests)
                    .then(function (responses) {
                        
                        responses.forEach(function (response) {
                            log.debug(response.statusCode);
                        });
                        
                    })
                    .fail(log.error);
    section
        div.
            .spread allows us to use functions that take multiple arguments as our
            fulfillment handler in place of .then.
        aside(class="notes").
            .spread is essentially .then, but with our callback being called with apply.
    section
        pre
            code.
                function updateOrder(order, email, label) {
                    
                    order.label = label;
                    
                    log.info('Sent email for ' + order.name);
                    log.debug(order.status);
                    
                    return order;
                }
                
                Q.all([createOrder(info), email(address), createLabel(info)])
                    .spread(updateOrder);
        aside(class="notes").
            Calling Q.all within a chain is not necessary however.  If you return an array of promises or values, the Q library will immediately call Q.all as part of the inbetween of that step.
section
    strong Q.nfcall or Q.denodeify
    section
        div.
            Q.nfcall allows us to wrap around asynchronous functions with a 
            "node-style" callback.
        aside(class="notes").
            Meaning callbacks that are error-first
    section(data-transition="slide-in fade-out")
        div This
        pre(class="fragment")
            code.
                fs.readFile('file.html', 'utf-8', function (err, contents) {
                    if (err) {
                        throw(err);
                    }
                    
                    doSomething(contents);
                });
    section(data-transition="fade-in slide-out")
        div Becomes this
        pre(class="fragment")
            code.
                Q.nfcall(fs.readFile, 'file.html', 'utf-8')
                    .then(function (contents) {
                        doSomething(contents);
                    })
                    .fail(function (error) {
                        log.error(error);
                    });
    section
        div.
            With Q.denodeify we can create a new promise returning function
    section
        pre
            code.
                var readFile = Q.denodeify(fs.readFile);
                
                readFile('file_one.html', 'utf-8').then(function (contents) {
                    log.debug('Read file one contents');
                });
                
                readFile('file_two.html', 'utf-8').then(function (contents) {
                    log.debug('Read file two contents');
                });
section 
    strong Promise Chaining
    section
        div.
            Promise chains are a powerful promise producing strategy when building
            large functions
    section
        pre
            code.
                function doSomethingElseSync(stuff) {
                    stuff.status = 'handled';
                    return stuff;
                }
                
                doSomething()
                    .then(function (response) {
                        return doSomethingElseSync(response);
                    })
                    .then(doSomethingElseAgain);
    section
        div.
            Other times we need multiple values from resolved promises for a function
        aside(class="notes").
            Thus we must nest together promises within a chain.
    section
        pre
            code.
                refillPetFood()
                .then(function (filled) {
                    
                    turnOffLights()
                    .then(function (finished) {
                        
                        if ((filled && finished) === true) {
                            leaveHouse();
                        }
                        
                    });
                    
                })
